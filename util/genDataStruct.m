function [Data, normalizingTerms] = genDataStruct(N, cond2include)
% [Data, normalizingTerms] = genDataStruct(N, cond2include)
%
% Compiles single-neuron trial-average PTSHs into population-level PSTHs.
%
% Args:
%   N: 1 x n struct where each element refers to individual neuron and has
%   field ".cond", which has Z elements, each of which itself is a struct
%   and refers to a single task condition with the following fields:
%       .psth: vector (T * 1) of trial-average firing rate of given neuron
%           at each of T time bins relative to event-of-interest.
%       .numTrials: integer of the number of trials contributing to the
%           trial-average in .psth (above)
%       .variableValues4Condition: vector (1 * P) of the values of the P
%           task variables (columns) for the present condition.
%   Additional fields will be ignored.
%   Note that the N struct is typically generated by getTrialAvgPSTHs().
%
%   cond2include: matrix (C * P) of the values of the P task variables
%       (columns) for the C conditions (rows) for which you wish to
%       compile trial-average data. Number of columns P and the specific
%       values of the variables must match those provided in
%       N.cond.variableValues4Condition (see above). Conditions (i.e.,
%       combinations of task variables) not provided in cond2include will
%       be ignored
%
% Returns:
%   Data: struct (1 * C) where each element refers to one of C conditions
%       and contains the following fields:
%       .A: matrix (T * N) of trial-average firing rate for each of N
%           neurons in each of T time bins.
%       .times: vector (1 * T) of times (at center) of T bins
%       .Predictors: vector (1 * P) of the values of the P task variables
%           for the given condition.
%       .trialRept: vector (1 * N) of number of trials contributing to
%           trial-average in .A for each of N neurons.

smoothFlg = false; % currently not supported
numConds = size(cond2include,1);
numNeus = length(N);

Data = struct();

for c = 1:numConds
    currentConds = cond2include(c,:);
    A = [];
    condRep = [];
    for n = 1:numNeus
        C = vertcat(N(n).cond.variableValues4Condition);
        % DK: MSK appears to be a bitmask to find the condition for the
        % current neuron that matches the current global condition.
        % ismember() may have been a simpler implementation, but here we
        % update the existing method to be flexible WRT to the number of
        % variables defining the condition (i.e. ==size(C,2) instead of
        % ==3)
        msk = sum(C== repmat(currentConds, size(C,1),1),2)==size(C,2);
        if sum(msk) ==0
            A(:,n)=0;
            Az(:,n)=0;
        else
            if smoothFlg
                A(:,n) = gFilter(1, N(n).cond(msk).psth);
                A(A<0) = 0;
            else
                A(:,n) = N(n).cond(msk).psth;
            end
                
        end
        condRep(n) = N(n).cond(msk).numTrials;
    end
    Data(c).A = A;
    Data(c).times = N(1).all_times;
    Data(c).Predictors = currentConds;
    Data(c).trialRept = condRep;
end

end % end main function

%% subfunction for smoothing -- not currently supported
function FiltSignal=gFilter(SD, inSignal)
    filtwidth=8*SD; % filter width
    b=fspecial('gaussian',[1,filtwidth],SD); % generate filter coefficients
    PadSignal=[repmat(mean(inSignal(1:SD,:),1), floor(filtwidth/2),1); inSignal;repmat(mean(inSignal(end-SD:end,:),1), floor(filtwidth/2),1)]; % padd signals with mean values at start and the end to handle filter shift
    FiltSignal=filter(b,1,PadSignal); % filter the signal
    FiltSignal=FiltSignal(2*floor(filtwidth/2):size(PadSignal,1)-1,:); % crop the signal to the right size of the input signal
end